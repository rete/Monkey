  /// \file convert.h
/*
 *
 * convert.h header template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 24 2017
 *
 * This file is part of Monkey libraries.
 *
 * Monkey is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Monkey is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Monkey.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */


#ifndef MONKEY_CONVERT_H
#define MONKEY_CONVERT_H

#include <memory>
#include <string>
#include <limits>
#include <sstream>
#include <algorithm>
#include <iostream>
#include <typeinfo>

#include <monkey/node.h>

namespace monkey {

  std::string &tolower(std::string& str) {
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    return str;
  }

  template <typename T>
  struct convert;

  namespace conversion {
    inline bool isInfinity(const std::string &input) {
      return input == ".inf" || input == ".Inf" || input == ".INF" ||
      input == "+.inf" || input == "+.Inf" || input == "+.INF";
    }

    inline bool isNegativeInfinity(const std::string &input) {
      return input == "-.inf" || input == "-.Inf" || input == "-.INF";
    }

    inline bool isNan(const std::string &input) {
      return input == ".nan" || input == ".NaN" || input == ".NAN";
    }
  }

  // Node spec
  template <>
  struct convert<Node>
  {
    static bool encode(Node &lhs, const Node &rhs)
    {
      lhs = rhs;
      return true;
    }

    static bool decode(const Node &node, Node &rhs)
    {
      rhs = node;
      return true;
    }
  };

  // std::string spec
  template <>
  struct convert<std::string>
  {
    static bool encode(Node &lhs, const std::string &rhs)
    {
      getchar();
      lhs.set(rhs);
      return true;
    }

    static bool decode(const Node &node, std::string &rhs)
    {
      if(!node.isScalar())
        return false;

      rhs = node.scalar();
      return true;
    }
  };

  // C-strings can only be encoded
  template <>
  struct convert<const char*> {
    static bool encode(Node &lhs, const char*const& rhs) { lhs.set(std::string(rhs)); return true; }
  };

  template <>
  struct convert<char*> {
    static bool encode(Node &lhs, const char*& rhs) { lhs.set(std::string(rhs)); return true; }
  };

  template <std::size_t N>
  struct convert<const char[N]> {
    static bool encode(Node &lhs, const char (&rhs)[N]) { lhs.set(std::string(rhs)); return true; }
  };

  template <std::size_t N>
  struct convert<char[N]> {
    static bool encode(Node &lhs, const char (&rhs)[N]) { lhs.set(std::string(rhs)); return true; }
  };

  // thank you yaml-cpp !
  #define MONKEY_DEFINE_CONVERT_STREAMING(Type, negative_op) \
  template <> \
  struct convert<Type> \
  { \
    static bool encode(Node &lhs, const Type &rhs) \
    { \
      std::stringstream stream; \
      stream.precision(std::numeric_limits<Type>::digits10 + 1); \
      stream << rhs; \
      lhs.set(stream.str()); \
      return true; \
    } \
    static bool decode(const Node &node, Type &rhs) \
    { \
      if(node.type() != Node::Scalar) \
        return false; \
      std::string scalar(node.scalar()); \
      std::stringstream stream(scalar); \
      stream.unsetf(std::ios::dec); \
      if ((stream >> std::noskipws >> rhs) && (stream >> std::ws).eof()) \
        return true; \
      if (std::numeric_limits<Type>::has_infinity) { \
        if (conversion::isInfinity(scalar)) { \
          rhs = std::numeric_limits<Type>::infinity(); \
          return true; \
        } \
        else if (conversion::isNegativeInfinity(scalar)) { \
          rhs = negative_op std::numeric_limits<Type>::infinity(); \
          return true; \
        } \
      } \
      if (std::numeric_limits<Type>::has_quiet_NaN && conversion::isNan(scalar)) { \
        rhs = std::numeric_limits<Type>::quiet_NaN(); \
        return true; \
      } \
      return false; \
    } \
  }

#define MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(type) MONKEY_DEFINE_CONVERT_STREAMING(type, -)
#define MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED(type) MONKEY_DEFINE_CONVERT_STREAMING(type, +)

  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(int);
  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(short);
  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(long);
  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(long long);
  MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED(unsigned);
  MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED(unsigned short);
  MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED(unsigned long);
  MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED(unsigned long long);

  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(char);
  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(signed char);
  MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED(unsigned char);

  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(float);
  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(double);
  MONKEY_DEFINE_CONVERT_STREAMING_SIGNED(long double);

#undef MONKEY_DEFINE_CONVERT_STREAMING_SIGNED
#undef MONKEY_DEFINE_CONVERT_STREAMING_UNSIGNED
#undef MONKEY_DEFINE_CONVERT_STREAMING

  // bool spec
  template <>
  struct convert<bool>
  {
    static bool encode(Node &lhs, bool rhs)
    {
      rhs ? lhs.set("true") : lhs.set("false");
      return true;
    }

    static bool decode(const Node &node, bool &rhs)
    {
      static const struct {
          std::string truename, falsename;
      } names[] = {
            {"y", "n"}, {"yes", "no"}, {"true", "false"}, {"on", "off"}
      };

      std::string scalar(node.scalar());
      tolower(scalar);

      for (unsigned i = 0; i < sizeof(names) / sizeof(names[0]); i++) {
        if (names[i].truename == scalar) {
          rhs = true;
          return true;
        }

        if (names[i].falsename == scalar) {
          rhs = false;
          return true;
        }
      }
      return false;
    }
  };

  // map spec
  template <typename T>
  struct convert<std::map<std::string,T>>
  {
    static bool encode(Node &lhs, const std::map<std::string, T> &rhs)
    {
      for(auto it = rhs.begin() ; it != rhs.end() ; ++it)
        lhs.insert(it->first, it->second);
      return true;
    }

    static bool decode(const Node &node, std::map<std::string,T> &rhs)
    {
      if(!node.isMap())
        return false;
      rhs.clear();
      for(auto it = node.begin() ; it != node.end() ; ++it)
        rhs[it->first] = it->second.as<T>();
      return true;
    }
  };

  // vector spec
  template <typename T>
  struct convert<std::vector<T>>
  {
    static bool encode(Node &lhs, const std::vector<T> &rhs)
    {
      for(auto it = rhs.begin() ; it != rhs.end() ; ++it)
        lhs.push_back(*it);
      return true;
    }

    static bool decode(const Node &node, std::vector<T> &rhs)
    {
      if(!node.isSequence())
        return false;
      rhs.clear();
      for(SequenceKey i=0 ; i<node.size() ; i++)
        rhs.push_back(node[i].as<T>());
      return true;
    }
  };

  // pair spec
  template <typename T, typename S>
  struct convert<std::pair<T,S>>
  {
    static bool encode(Node &lhs, const std::pair<T,S> &rhs)
    {
      lhs.push_back(rhs.first);
      lhs.push_back(rhs.second);
      return true;
    }

    static bool decode(const Node &node, std::pair<T,S> &rhs)
    {
      if(!node.isSequence())
        return false;
      if(node.size() != 2)
        return false;
      rhs.first = node[0].as<T>();
      rhs.second = node[1].as<T>();
      return true;
    }
  };

}

#endif  //  MONKEY_CONVERT_H
