  /// \file node.cc
/*
 *
 * node.cc source template automatically generated by a class generator
 * Creation date : mar. fï¿½vr. 21 2017
 *
 * This file is part of Monkey libraries.
 *
 * Monkey is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Monkey is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Monkey.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */

#include <iostream>
#include <monkey/node.h>

namespace monkey {
  
  const Node &Node::null = Node(Node::Null);

  Node::Node(Node::Type type)
  {
    m_nodeModel.m_nodeType = type;
  }

  Node::Node(const Node &rhs)
  {
    m_nodeModel.m_nodeType = Node::Null;
    *this = rhs;
  }

  Node::Type Node::type() const
  {
    return m_nodeModel.m_nodeType;
  }

  std::string Node::scalar() const
  {
    return (m_nodeModel.m_nodeType == Node::Scalar) ? m_nodeModel.m_nodeValue.m_scalar : std::string("");
  }

  bool Node::isNull() const
  {
    return (m_nodeModel.m_nodeType == Node::Null);
  }

  bool Node::isScalar() const
  {
    return (m_nodeModel.m_nodeType == Node::Scalar);
  }

  bool Node::isSequence() const
  {
    return (m_nodeModel.m_nodeType == Node::Sequence);
  }

  bool Node::isMap() const
  {
    return (m_nodeModel.m_nodeType == Node::Map);
  }

  size_t Node::size() const
  {
    if(m_nodeModel.m_nodeType == Node::Map)
      return m_nodeModel.m_nodeValue.m_map.size();
    else if(m_nodeModel.m_nodeType == Node::Sequence)
      return m_nodeModel.m_nodeValue.m_sequence.size();
    else
      return 0;
  }

  void Node::push_back(const Node &rhs)
  {
    if(m_nodeModel.m_nodeType != Node::Sequence)
      this->changeTo(Node::Sequence);

    m_nodeModel.m_nodeValue.m_sequence.push_back(rhs);
  }

  Node::const_iterator Node::begin() const
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      throw; // TODO implement exceptions

    return m_nodeModel.m_nodeValue.m_map.begin();
  }

  Node::iterator Node::begin()
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      throw; // TODO implement exceptions

    return m_nodeModel.m_nodeValue.m_map.begin();
  }

  Node::const_iterator Node::end() const
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      throw; // TODO implement exceptions

    return m_nodeModel.m_nodeValue.m_map.end();
  }

  Node::iterator Node::end()
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      throw; // TODO implement exceptions

    return m_nodeModel.m_nodeValue.m_map.end();
  }

  Node Node::operator[](SequenceKey key)
  {
    if(m_nodeModel.m_nodeType != Node::Sequence)
      return std::move(Node(Node::Null));

    if(key >= m_nodeModel.m_nodeValue.m_sequence.size())
      throw; // TODO implement exceptions

    return m_nodeModel.m_nodeValue.m_sequence.at(key); // return copy
  }

  const Node Node::operator[](SequenceKey key) const
  {
    if(m_nodeModel.m_nodeType != Node::Sequence)
      return std::move(Node(Node::Null));

    if(key >= m_nodeModel.m_nodeValue.m_sequence.size())
      throw; // TODO implement exceptions

    return m_nodeModel.m_nodeValue.m_sequence.at(key); // return copy
  }

  bool Node::insert(const MapKey &key, const Node &value)
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      this->changeTo(Node::Map);
    return m_nodeModel.m_nodeValue.m_map.insert(MapContainer::value_type(key, value)).second;
  }


  const Node &Node::operator[](const MapKey &key) const
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      this->changeTo(Node::Map);

    const_iterator iter = m_nodeModel.m_nodeValue.m_map.find(key);

    if(iter == m_nodeModel.m_nodeValue.m_map.end())
      return Node::null;

    return iter->second;
  }

  bool Node::remove(const MapKey &key)
  {
    if(m_nodeModel.m_nodeType != Node::Map)
      throw; // TODO implement exceptions
    return (1 == m_nodeModel.m_nodeValue.m_map.erase(key));
  }

  Node &Node::operator=(const Node &rhs)
  {
    this->reset();
    m_nodeModel.m_nodeType = rhs.m_nodeModel.m_nodeType;

    switch(m_nodeModel.m_nodeType)
    {
      case Scalar:
        m_nodeModel.m_nodeValue.m_scalar = rhs.m_nodeModel.m_nodeValue.m_scalar;
        break;
      case Sequence:
        m_nodeModel.m_nodeValue.m_sequence = rhs.m_nodeModel.m_nodeValue.m_sequence;
        break;
      case Map:
        m_nodeModel.m_nodeValue.m_map = rhs.m_nodeModel.m_nodeValue.m_map;
        break;
      case Null:
      default:
        break;
    }

    return *this;
  }

  void Node::reset()
  {
    this->changeTo(Node::Null);
  }


  void Node::changeTo(Node::Type type) const
  {
    switch(m_nodeModel.m_nodeType)
    {
      case Node::Scalar:
        m_nodeModel.m_nodeValue.m_scalar.clear();
        break;
      case Node::Sequence:
        m_nodeModel.m_nodeValue.m_sequence.clear();
        break;
      case Node::Map:
        m_nodeModel.m_nodeValue.m_map.clear();
        break;
      default:
        break;
    }

    m_nodeModel.m_nodeType = type;
  }

}
